
// EXAMPLE 2

#pragma once

//#include <Python.h>

// TODO: let's pass back a numpy array instead of a bytearray.
// #include <numpy/arrayobject.h>
// also include numpy in IDE ..3.4\python\lib\site-packages\numpy\core\include

#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <array>

/////////////////////////////////////////////////////
// Mirror Some Mesh Struct
//////////////////////////////////////////////////////

//3.4/source/blender/makesdna/DNA_meshdata_types.h

/* Mesh Vertices. Typically accessed from #Mesh.verts()*/
typedef struct MVert {
  float co[3];
  /*Deprecated flag for storing hide status and selection, which are now stored in separate generic attributes. Kept for file read and write. */
  char flag_legacy;
  /* Deprecated bevel weight storage, now located in #CD_BWEIGHT, except for file read and write. */
  char bweight_legacy;
  char _pad[2];
} MVert;

/* Mesh Edges. Typically accessed with #Mesh.edges() */
typedef struct MEdge {
  /* Un-ordered vertex indices (cannot match). */
  unsigned int v1, v2;
  /* Deprecated edge crease, now located in #CD_CREASE, except for file read and write. */
  char crease_legacy;
  /*Deprecated bevel weight storage, now located in #CD_BWEIGHT, except for file read and write.*/
  char bweight_legacy;
  short flag;
} MEdge;

/* Mesh Faces.This only stores the polygon size & flags, the vertex & edge indices are stored in the #MLoop. Typically accessed with #Mesh.polys(). */
typedef struct MPoly {
  /* Offset into loop array and number of loops in the face. */
  int loopstart;
  /* Keep signed since we need to subtract when getting the previous loop. */
  int totloop;
  /* Deprecated material index. Now stored in the "material_index" attribute, but kept for IO. */
  short mat_nr_legacy;
  char flag, _pad;
} MPoly;

/* Mesh Face Corners. "Loop" is an internal name for the corner of a polygon (#MPoly). Typically accessed with #Mesh.loops(). */
typedef struct MLoop {
  /* Vertex index into an #MVert array. */
  unsigned int v;
  /* Edge index into an #MEdge array. */
  unsigned int e;
} MLoop;


/////////////////////////////////////////////////////
// Process our elements arrays into a Mesh Format
//////////////////////////////////////////////////////


struct SimpleMeshVertex {
    float x, y, z; // Vertex coordinates
};
struct SimpleMeshEdge {
    int v1, v2; // Indices of the two vertices that form the edge
};
struct SimpleMeshFace {
    std::vector<int> vertices; // Indices of the vertices that form the face
};
struct SimpleMesh {
    std::vector<SimpleMeshVertex> vertices;
    std::vector<SimpleMeshEdge> edges;
    std::vector<SimpleMeshFace> faces;
};

// Function entirely generated by GPT4
SimpleMesh convert_to_simple_mesh(MVert* vertices, int num_verts, MEdge* edges, int num_edges, MPoly* polygons, int num_polys, MLoop* loops, int num_loops) {
    SimpleMesh simple_mesh;

    // Convert vertices
    for (int i = 0; i < num_verts; ++i) {
        SimpleMeshVertex vertex;
        vertex.x = vertices[i].co[0];
        vertex.y = vertices[i].co[1];
        vertex.z = vertices[i].co[2];
        simple_mesh.vertices.push_back(vertex);
    }
    // Convert edges
    for (int i = 0; i < num_edges; ++i) {
        SimpleMeshEdge edge;
        edge.v1 = edges[i].v1;
        edge.v2 = edges[i].v2;
        simple_mesh.edges.push_back(edge);
    }
    // Convert faces (polygons)
    for (int i = 0; i < num_polys; ++i) {
        SimpleMeshFace face;
        int loopstart = polygons[i].loopstart;
        int totloop = polygons[i].totloop;

        for (int j = loopstart; j < loopstart + totloop; ++j) {
            face.vertices.push_back(loops[j].v);
        }
        simple_mesh.faces.push_back(face);
    }

    return simple_mesh;
}

// Function entirely generated by GPT4. yeah... 
std::vector<unsigned char> renderMesh(const SimpleMesh& mesh, int width, int height) {
    std::vector<unsigned char> pixels(width * height * 4, 0);

    // Find the center of the mesh
    float center_x = 0, center_y = 0, center_z = 0;
    for (const auto& v : mesh.vertices) {
        center_x += v.x;
        center_y += v.y;
        center_z += v.z;
    }
    center_x /= mesh.vertices.size();
    center_y /= mesh.vertices.size();
    center_z /= mesh.vertices.size();

    // Compute the scaling factor to fit the mesh in the image
    float max_extent = 0;
    for (const auto& v : mesh.vertices) {
        float dx = v.x - center_x;
        float dy = v.y - center_y;
        float dz = v.z - center_z;
        max_extent = std::max(max_extent, std::max(std::max(std::abs(dx), std::abs(dy)), std::abs(dz)));
    }
    float scale = std::min(width, height) / (2 * max_extent);

    // Transform the vertices to screen space
    std::vector<std::pair<int, int>> vertices2d(mesh.vertices.size());
    for (int i = 0; i < mesh.vertices.size(); i++) {
        float x = mesh.vertices[i].x - center_x;
        float y = mesh.vertices[i].y - center_y;
        float z = mesh.vertices[i].z - center_z;
        vertices2d[i].first = static_cast<int>(std::round(width / 2.0f + x * scale));
        vertices2d[i].second = static_cast<int>(std::round(height / 2.0f + y * scale));
    }

    // Render the edges
    for (const auto& edge : mesh.edges) {
        std::pair<int, int> p1 = vertices2d[edge.v1];
        std::pair<int, int> p2 = vertices2d[edge.v2];
        int x1 = p1.first;
        int y1 = p1.second;
        int x2 = p2.first;
        int y2 = p2.second;

        // Bresenham's line algorithm
        int dx = std::abs(x2 - x1);
        int dy = std::abs(y2 - y1);
        int sx = x1 < x2 ? 1 : -1;
        int sy = y1 < y2 ? 1 : -1;
        int err = dx - dy;
        while (x1 != x2 || y1 != y2) {
            if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height) {
                int index = (x1 + y1 * width) * 4;
                pixels[index] = 255;
                pixels[index + 1] = 255;
                pixels[index + 2] = 255;
                pixels[index + 3] = 255;
            }
            int err2 = 2 * err;
            if (err2 > -dy) {
                err -= dy;
                x1 += sx;
            }
            if (err2 < dx) {
                err += dx;
                y1 += sy;
            }
        }
    }

    return pixels;
}


//////////////////////////////////////////////////////
// Define pyd function 
//////////////////////////////////////////////////////


// Access mesh data
static PyObject* read_mesh_elements(PyObject* self, PyObject* args) {
    unsigned long long vertices_address, edges_address, polygons_address, loops_address;
    int num_verts, num_edges, num_polys, num_loops;

    if (!PyArg_ParseTuple(args, "KKKKiiii",
        &vertices_address, &edges_address, &polygons_address, &loops_address,
        &num_verts, &num_edges, &num_polys, &num_loops)) {
        return nullptr;
    }

    // Cast addresses to pointers
    MVert* vertices = reinterpret_cast<MVert*>(static_cast<uintptr_t>(vertices_address));
    MEdge* edges = reinterpret_cast<MEdge*>(static_cast<uintptr_t>(edges_address));
    MPoly* polygons = reinterpret_cast<MPoly*>(static_cast<uintptr_t>(polygons_address));
    MLoop* loops = reinterpret_cast<MLoop*>(static_cast<uintptr_t>(loops_address));

    // Testing if the elements correspond to python

    /*
    std::ostringstream output;
    output << "C++ first 5 Vertices co:\n";
    for (int i = 0; i < 6; ++i) {
        MVert& vert = vertices[i];
        output << "    " << i << ": (" << vert.co[0] << ", " << vert.co[1] << ", " << vert.co[2] << ")\n";
    }
    output << "\nC++ first 5 Edges vertid:\n";
    for (int i = 0; i < 6; ++i) {
        MEdge& edge = edges[i];
        output << "    " << i << ": (" << edge.v1 << ", " << edge.v2 << ")\n";
    }
    output << "\nC++ first 5 Polygons totloop:\n";
    for (int i = 0; i < 6; ++i) {
        MPoly& poly = polygons[i];
        output << "    " << i << ": totloop=" << poly.totloop << "\n";
    }
    std::cout << output.str();
    */
        
    // Convert our arrays to a simple mesh format
    SimpleMesh simple_mesh = convert_to_simple_mesh(vertices, num_verts, edges, num_edges, polygons, num_polys, loops, num_loops);
    
    // Render this mesh
    std::vector<unsigned char> pixels = renderMesh(simple_mesh, 1920, 1080);
      
    // Convert the pixels to a Python bytearray
    PyObject* pixel_array = PyByteArray_FromStringAndSize(reinterpret_cast<const char*>(pixels.data()), pixels.size());

    //TODO: let's pass back a numpy array instead of a bytearray.
    
    return pixel_array;
};

